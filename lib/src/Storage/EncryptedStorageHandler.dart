import 'dart:convert';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'IStorageHandler.dart';
import '../Metriqus.dart';

/// EncryptedStorageHandler is a IStorageHandler instance which encrypts data before saving locally.
/// encryptionKey is easily changeable in class. If you change it all existing data will become unreadable
class EncryptedStorageHandler implements IStorageHandler {
  final String _encryptionKey = ";V2)9.;&SqZB]{p4";

  // Cache for sync operations
  final Map<String, String> _cache = {};
  final Map<String, bool> _existsCache = {};
  bool _cacheInitialized = false;

  EncryptedStorageHandler() {
    Metriqus.verboseLog(
        'üîß [STORAGE] EncryptedStorageHandler constructor called');
    // Initialize cache asynchronously
    _initializeCache();
  }

  /// Wait for cache initialization to complete
  Future<void> waitForCacheInitialization() async {
    while (!_cacheInitialized) {
      await Future.delayed(Duration(milliseconds: 10));
    }
  }

  /// Initialize cache by preloading known keys
  Future<void> _initializeCache() async {
    try {
      Metriqus.verboseLog('üîß [STORAGE] Starting cache initialization');
      // Preload commonly used keys
      final commonKeys = [
        "metriqus_current_events",
        "metriqus_events_to_send",
        "metriqus_event_last_flush_time",
        "UniqueUserIdentifier", // Actual key used by UniqueUserIdentifier class
        "metriqus_user_attributes",
        "metriqus_first_launch_time",
        "metriqus_last_session_start_time",
        "metriqus_session_id",
        "metriqus_last_send_attribution_date",
        "metriqus_remote_settings",
        "geolocation_settings",
        "geolocation_last_fetched_time",
        "geolocation",
      ];

      Metriqus.verboseLog(
          'üîß [STORAGE] Will preload ${commonKeys.length} keys: $commonKeys');

      for (String key in commonKeys) {
        await _preloadKey(key);
      }

      // Ensure user ID exists
      await _ensureUserIdExists();

      _cacheInitialized = true;
      Metriqus.verboseLog('üîß [STORAGE] Cache initialization completed');
      Metriqus.verboseLog(
        'üîß [STORAGE] Cached keys: ${_existsCache.keys.toList()}',
      );
      Metriqus.verboseLog(
        'üîß [STORAGE] Attribution key in cache: ${_existsCache.containsKey("metriqus_last_send_attribution_date")}',
      );
    } catch (e) {
      Metriqus.errorLog('Error initializing cache: $e');
      _cacheInitialized = true; // Mark as initialized even if failed
    }
  }

  /// Ensure user ID exists in cache
  Future<void> _ensureUserIdExists() async {
    try {
      const userIdKey = "UniqueUserIdentifier"; // Use the actual key

      if (!_cache.containsKey(userIdKey) || _cache[userIdKey]!.isEmpty) {
        // Don't generate here, let the UniqueUserIdentifier class handle it
        Metriqus.verboseLog(
          'üîß [STORAGE] User ID will be generated by UniqueUserIdentifier class',
        );
      } else {
        Metriqus.verboseLog(
          'üîß [STORAGE] Existing user ID found: ${_cache[userIdKey]}',
        );
      }
    } catch (e) {
      Metriqus.errorLog('üîß [STORAGE] Error ensuring user ID: $e');
    }
  }

  /// Preload a specific key into cache
  Future<void> _preloadKey(String saveKey) async {
    try {
      final directory = await getApplicationSupportDirectory();
      final encryptedKey = _encryptDecryptForFileName(saveKey);
      final file = File('${directory.path}/$encryptedKey');

      final exists = await file.exists();
      _existsCache[saveKey] = exists;

      if (exists) {
        final encryptedData = await file.readAsString();
        final decryptedData = _encryptDecrypt(encryptedData);

        // Validate JSON data for event-related keys
        if ((saveKey == "metriqus_current_events" ||
                saveKey == "metriqus_events_to_send") &&
            decryptedData.isNotEmpty) {
          // Check if JSON is malformed
          if (decryptedData.startsWith('[]') && decryptedData.length > 2) {
            Metriqus.errorLog(
              'üîß [STORAGE] Detected malformed JSON for $saveKey, resetting to empty array',
            );
            _cache[saveKey] = '[]';
            _existsCache[saveKey] = true;
            // Fix the file immediately
            try {
              final encryptedData = _encryptDecrypt('[]');
              await file.writeAsString(encryptedData);
              Metriqus.verboseLog(
                'üîß [STORAGE] Fixed malformed JSON file for $saveKey',
              );
            } catch (e) {
              Metriqus.errorLog(
                'üîß [STORAGE] Error fixing malformed JSON file: $e',
              );
            }
          } else {
            _cache[saveKey] = decryptedData;
          }
        } else {
          _cache[saveKey] = decryptedData;
        }
      }
    } catch (e) {
      Metriqus.errorLog('Error preloading key $saveKey: $e');
      _existsCache[saveKey] = false;
    }
  }

  @override
  void saveFile(String saveKey, String saveData) {
    try {
      Metriqus.verboseLog('üîß [STORAGE] saveFile called: $saveKey = $saveData');

      // Cache the data for immediate sync access
      _cache[saveKey] = saveData;
      _existsCache[saveKey] = true;

      Metriqus.verboseLog(
          'üîß [STORAGE] Data cached successfully for key: $saveKey');

      // Save asynchronously in background
      _saveFileAsync(saveKey, saveData);

      // Debug log for attribution key
      if (saveKey == "metriqus_last_send_attribution_date") {
        Metriqus.verboseLog(
            'üéØ [STORAGE] Attribution date saved to cache: $saveData');
        Metriqus.verboseLog(
          'üéØ [STORAGE] Cache now contains key: ${_existsCache.containsKey(saveKey)}',
        );
        Metriqus.verboseLog(
            'üéØ [STORAGE] Cache value: ${_existsCache[saveKey]}');
      }

      // Debug log for queue operations (only for important events)
      if (saveKey == "metriqus_current_events" && saveData != "[]") {
        Metriqus.verboseLog(
          'üîß [STORAGE] Saving current events: ${saveData.length > 100 ? saveData.substring(0, 100) + "..." : saveData}',
        );
      }
    } catch (e) {
      Metriqus.errorLog('‚ùå [STORAGE] Error in saveFile: $e');
      Metriqus.errorLog('Error in saveFile: $e');
    }
  }

  Future<void> _saveFileAsync(String saveKey, String saveData) async {
    try {
      Metriqus.verboseLog(
          'üîß [STORAGE] _saveFileAsync called for key: $saveKey');

      final directory = await getApplicationSupportDirectory();
      final encryptedKey = _encryptDecryptForFileName(saveKey);
      final file = File('${directory.path}/$encryptedKey');

      Metriqus.verboseLog('üîß [STORAGE] File path: ${file.path}');

      await file.parent.create(recursive: true);
      final encryptedData = _encryptDecrypt(saveData);
      await file.writeAsString(encryptedData);

      Metriqus.verboseLog(
          'üîß [STORAGE] File written successfully for key: $saveKey');

      // Special log for attribution key
      if (saveKey == "metriqus_last_send_attribution_date") {
        Metriqus.verboseLog(
            'üéØ [STORAGE] Attribution date written to disk successfully');
        final exists = await file.exists();
        Metriqus.verboseLog('üéØ [STORAGE] File exists after write: $exists');
      }
    } catch (e) {
      Metriqus.errorLog(
          '‚ùå [STORAGE] Error in _saveFileAsync for key $saveKey: $e');
      Metriqus.errorLog('Error occurred when trying to save event data: $e');
    }
  }

  @override
  String readFile(String saveKey) {
    // First check cache
    if (_cache.containsKey(saveKey)) {
      final value = _cache[saveKey]!;

      // JSON validation already done during cache initialization
      // No need to validate again here

      // Debug log for queue operations
      if (saveKey == "metriqus_current_events") {
        Metriqus.verboseLog(
          'üîß [STORAGE] Reading current events from cache: ${value.length > 100 ? value.substring(0, 100) + "..." : value}',
        );
      }
      return value;
    }

    // If cache not initialized yet or key not found, try async load
    if (!_cacheInitialized) {
      // Cache not ready yet, return empty for now
      // The async initialization will populate the cache
      _preloadKey(saveKey); // Trigger async load
      Metriqus.verboseLog(
        'üîß [STORAGE] Cache not initialized for key: $saveKey, returning empty',
      );
      return "";
    }

    // Cache is initialized but key doesn't exist
    Metriqus.verboseLog(
      'üîß [STORAGE] Key not found in cache: $saveKey, returning empty',
    );
    return "";
  }

  @override
  Future<void> saveFileAsync(String saveKey, String saveData) async {
    // Update cache
    _cache[saveKey] = saveData;
    _existsCache[saveKey] = true;

    await _saveFileAsync(saveKey, saveData);
  }

  @override
  Future<String> readFileAsync(String saveKey) async {
    try {
      final directory = await getApplicationSupportDirectory();
      final encryptedKey = _encryptDecryptForFileName(saveKey);
      final file = File('${directory.path}/$encryptedKey');

      if (await file.exists()) {
        final encryptedData = await file.readAsString();
        final decryptedData = _encryptDecrypt(encryptedData);

        // Update cache
        _cache[saveKey] = decryptedData;
        _existsCache[saveKey] = true;

        return decryptedData;
      }
    } catch (e) {
      Metriqus.errorLog('Error occurred when trying to read event data: $e');
    }

    return "";
  }

  @override
  bool checkKeyExist(String saveKey) {
    // FIRST - Special handling for attribution date key
    if (saveKey == "metriqus_last_send_attribution_date") {
      Metriqus.verboseLog(
        'üéØüéØüéØ [STORAGE] ATTRIBUTION KEY DETECTED - SPECIAL HANDLING üéØüéØüéØ',
      );
      Metriqus.verboseLog('üéØ [STORAGE] Cache initialized: $_cacheInitialized');
      Metriqus.verboseLog(
        'üéØ [STORAGE] Key in existsCache: ${_existsCache.containsKey(saveKey)}',
      );

      // Return false for now to force attribution sending
      Metriqus.verboseLog(
          'üéØ [STORAGE] Forcing false result to ensure attribution is sent');
      return false;
    }

    Metriqus.verboseLog('üîß [STORAGE] checkKeyExist called for: $saveKey');
    Metriqus.verboseLog('üîß [STORAGE] Checking key existence: $saveKey');
    Metriqus.verboseLog('üîß [STORAGE] Cache initialized: $_cacheInitialized');
    Metriqus.verboseLog(
      'üîß [STORAGE] Key in existsCache: ${_existsCache.containsKey(saveKey)}',
    );

    // First check cache
    if (_existsCache.containsKey(saveKey)) {
      final exists = _existsCache[saveKey]!;
      Metriqus.verboseLog(
        'üîß [STORAGE] Found key in cache: $saveKey = $exists',
      );
      return exists;
    }

    // If cache not initialized yet, trigger async load and return false for now
    if (!_cacheInitialized) {
      _preloadKey(saveKey); // Trigger async load
      Metriqus.verboseLog(
        'üîß [STORAGE] Cache not initialized for key existence check: $saveKey, returning false',
      );
      return false;
    }

    // Cache is initialized but key doesn't exist in cache, so it doesn't exist
    Metriqus.verboseLog(
      'üîß [STORAGE] Key existence not found in cache: $saveKey, returning false',
    );
    return false;
  }

  @override
  void deleteFile(String saveKey) {
    // Remove from cache
    _cache.remove(saveKey);
    _existsCache[saveKey] = false;

    // Delete asynchronously in background
    _deleteFileAsync(saveKey);
  }

  Future<void> _deleteFileAsync(String saveKey) async {
    try {
      final directory = await getApplicationSupportDirectory();
      final encryptedKey = _encryptDecryptForFileName(saveKey);
      final file = File('${directory.path}/$encryptedKey');

      if (await file.exists()) {
        await file.delete();
      }
    } catch (e) {
      Metriqus.errorLog('Error occurred when trying to delete file: $e');
    }
  }

  /// Simple XOR encryption/decryption
  String _encryptDecrypt(String data) {
    String modifiedData = "";
    for (int i = 0; i < data.length; i++) {
      modifiedData += String.fromCharCode(
        data.codeUnitAt(i) ^
            _encryptionKey.codeUnitAt(i % _encryptionKey.length),
      );
    }
    return modifiedData;
  }

  /// Encrypt filename to make it file-system safe
  String _encryptDecryptForFileName(String data) {
    // Perform XOR encryption
    String modifiedData = "";
    for (int i = 0; i < data.length; i++) {
      modifiedData += String.fromCharCode(
        data.codeUnitAt(i) ^
            _encryptionKey.codeUnitAt(i % _encryptionKey.length),
      );
    }

    // Convert to base64 and make it URL-safe
    final bytes = utf8.encode(modifiedData);
    String fileNameSafeString = base64Encode(bytes)
        .replaceAll('+', '-') // Replace '+' with '-'
        .replaceAll('/', '_') // Replace '/' with '_'
        .replaceAll('=', ''); // Remove '=' padding

    return fileNameSafeString;
  }
}
